var tipuesearch = {"pages":[{"title":"About","text":"40723150 UniversityProject 課程倉儲： https://github.com/s40723150/UniversityProject 內容管理： https://s40723150.github.io/UniversityProject/ 課程投影片： https://s40723150.github.io/UniversityProject/reveal 課程網誌： https://s40723150.github.io/UniversityProject/blog","tags":"misc","url":"./pages/about/"},{"title":"Oct 19, 2020 日誌","text":"看 neural_network_in_python.pdf 安裝 NVIDIA CUDA 10.1 和 cudnn 7.6.5 Download NVIDIA CUDA 10.1 https://developer.nvidia.com/cuda-10.1-download-archive-base Download cudnn 7.6.5 https://developer.nvidia.com/rdp/cudnn-archive Put the cudnn 7.6.5 in C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1 Run the tensorflow module. TensorFlowKeras import tensorflow as tf from tensorflow.keras import layers from tensorflow.keras.layers import Activation, Dense import numpy as np # X = input of our 3 input XOR gate # set up the inputs of the neural network (right from the table) X = np.array(([0,0,0],[0,0,1],[0,1,0], [0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]), dtype=float) # y = our output of our neural network y = np.array(([1], [0], [0], [0], [0], [0], [0], [1]), dtype=float) model = tf.keras.Sequential() model.add(Dense(4, input_dim=3, activation='relu', use_bias=True)) #model.add(Dense(4, activation='relu', use_bias=True)) model.add(Dense(1, activation='sigmoid', use_bias=True)) model.compile(loss='mean_squared_error', optimizer='adam', metrics=['binary_accuracy']) print (model.get_weights()) history = model.fit(X, y, epochs=2000, validation_data = (X, y)) model.summary() # printing out to file loss_history = history.history[\"loss\"] numpy_loss_history = np.array(loss_history) np.savetxt(\"loss_history.txt\", numpy_loss_history, delimiter=\"\\n\") binary_accuracy_history = history.history[\"binary_accuracy\"] numpy_binary_accuracy = np.array(binary_accuracy_history) np.savetxt(\"binary_accuracy.txt\", numpy_binary_accuracy, delimiter=\"\\n\") print(np.mean(history.history[\"binary_accuracy\"])) result = model.predict(X ).round() print (result)","tags":"日誌","url":"./Ocv_19_2020.html"},{"title":"Oct 13, 2020 日誌","text":"看 neural_network_in_python.pdf Practice neural network with python. 2LayerNeuralNetwork.py # 2 Layer Neural Network in NumPy import numpy as np # X = input of our 3 input XOR gate # set up the inputs of the neural network (right from the table) X = np.array(([0,0,0],[0,0,1],[0,1,0], [0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]), dtype=float) # y = our output of our neural network y = np.array(([1], [0], [0], [0], [0], [0], [0], [1]), dtype=float) # what value we want to predict xPredicted = np.array(([0,0,1]), dtype=float) X = X/np.amax(X, axis=0) # maximum of X input array # maximum of xPredicted (our input data for the prediction) xPredicted = xPredicted/np.amax(xPredicted, axis=0) # set up our Loss file for graphing lossFile = open(\"SumSquaredLossList.csv\", \"w\") class Neural_Network (object): def __init__(self): #parameters self.inputLayerSize = 3 # X1,X2,X3 self.outputLayerSize = 1 # Y1 self.hiddenLayerSize = 4 # Size of the hidden layer # build weights of each layer # set to random values # look at the interconnection diagram to make sense of this # 3x4 matrix for input to hidden self.W1 = np.random.randn(self.inputLayerSize, self.hiddenLayerSize) # 4x1 matrix for hidden layer to output self.W2 = np.random.randn(self.hiddenLayerSize, self.outputLayerSize) def feedForward(self, X): # dot product of X (input) and first set of 3x4 weights self.z = np.dot(X, self.W1) # the activationSigmoid activation function - neural magic self.z2 = self.activationSigmoid(self.z) # dot product of hidden layer (z2) and second set of 4x1 weights self.z3 = np.dot(self.z2, self.W2) # final activation function - more neural magic o = self.activationSigmoid(self.z3) return o def backwardPropagate(self, X, y, o): # backward propagate through the network # calculate the error in output self.o_error = y - o # apply derivative of activationSigmoid to error self.o_delta = self.o_error * self.activationSigmoidPrime(o) # z2 error: how much our hidden layer weights contributed to output # error self.z2_error = self.o_delta.dot(self.W2.T) # applying derivative of activationSigmoid to z2 error self.z2_delta = self.z2_error * self.activationSigmoidPrime(self.z2) # adjusting first set (inputLayer --> hiddenLayer) weights self.W1 += X.T.dot(self.z2_delta) # adjusting second set (hiddenLayer --> outputLayer) weights self.W2 += self.z2.T.dot(self.o_delta) def trainNetwork(self, X, y): # feed forward the loop o = self.feedForward(X) # and then back propagate the values (feedback) self.backwardPropagate(X, y, o) def activationSigmoid(self, s): # activation function # simple activationSigmoid curve as in the book return 1 / (1 + np.exp(-s)) def activationSigmoidPrime(self, s): # First derivative of activationSigmoid # calculus time! return s * (1 - s) def saveSumSquaredLossList(self,i,error): lossFile.write(str(i)+\",\"+str(error.tolist())+'\\n') def saveWeights(self): # save this in order to reproduce our cool network np.savetxt(\"weightsLayer1.txt\", self.W1, fmt=\"%s\") np.savetxt(\"weightsLayer2.txt\", self.W2, fmt=\"%s\") def predictOutput(self): print (\"Predicted XOR output data based on trained weights: \") print (\"Expected (X1-X3): \\n\" + str(xPredicted)) print (\"Output (Y1): \\n\" + str(self.feedForward(xPredicted))) myNeuralNetwork = Neural_Network() trainingEpochs = 1000 #trainingEpochs = 100000 for i in range(trainingEpochs): # train myNeuralNetwork 1,000 times print (\"Epoch # \" + str(i) + \"\\n\") print (\"Network Input : \\n\" + str(X)) print (\"Expected Output of XOR Gate Neural Network: \\n\" + str(y)) print (\"Actual Output from XOR Gate Neural Network: \\n\" + str(myNeuralNetwork.feedForward(X))) # mean sum squared loss Loss = np.mean(np.square(y - myNeuralNetwork.feedForward(X))) myNeuralNetwork.saveSumSquaredLossList(i,Loss) print (\"Sum Squared Loss: \\n\" + str(Loss)) print (\"\\n\") myNeuralNetwork.trainNetwork(X, y) myNeuralNetwork.saveWeights() myNeuralNetwork.predictOutput()","tags":"日誌","url":"./Ocv_13_2020.html"},{"title":"Oct 12, 2020 日誌","text":"看 neural_network_in_python.pdf feed-forward：input data feeds in only one direction. backpropagation：performing a task using an iterative approach for trial and error. steepness：gradient. the choices of the weight and the biases determines the strength of prediction of the individual neurons. bias：shift the enitre curve to the right or left. weight：affect the steepness of the activation function curve. numpy array axis 0 : vertical axis.(column) axis 1：horizontal axis.(row) np.dot : 矩陣點積。 np.amax：矩陣column(axis0)或row(axis1)的最大值。","tags":"日誌","url":"./Ocv_12_2020.html"},{"title":"Sep 20, 2020 日誌","text":"在 blogger 加入程式碼顯示區塊。 在 Blogger 上，程式碼的顯示預設的樣式看起來和內文相近，而且當程式碼內容單行的內容太多的時候 文字內容會遮到側邊版面的內容，所以就問老師要怎麼解決，老師提供一些資訊：要將 highliter javascipt 的標註碼，加到 template 中。 在 blogger 的範本 (template) 編輯 html ，在 </head > 前插入 css 和 javascript 所讀取程式的位置，和顯示設定： SyntaxHighlighter.all() SyntaxHighlighter.defaults[&#39;toolbar&#39;] = false;","tags":"日誌","url":"./Sep_20_2020.html"},{"title":"Sep16, 2020 日誌","text":"學會用 Gmail API 寄信，和上傳檔案到 Google Drive。 在我們開始用 Gmail 和 Google Drive 的 API 前到 console.develolpers 在側邊面板的資料庫 (Library) 加入 Gmail API 和 Google Drive API， 設定 OAuth 同意畫面 ( OAuth constent screen )並在憑證頁面(Credetials)新增一個 OAuth 2 的用戶端憑證 (OAuth 2 Client ID)，類型為電腦應用程式(Desktop app)，完成建立後，下載 json 檔 (之後認證會需要用到) Gmail API translate json to pickle import pickle from google_auth_oauthlib.flow import InstalledAppFlow from httplib2 import Http from googleapiclient.discovery import build creds = None SCOPES = 'https://www.googleapis.com/auth/gmail.send' # Allows sending only, not reading flow = InstalledAppFlow.from_client_secrets_file( './../cilent_gm_blogger.json', SCOPES) creds = flow.run_local_server(port=0) # Save the credentials for the naext run with open('./../client_gmail.pickle', 'wb') as token: pickle.dump(creds, token) service = build('gmail', 'v1', credentials=creds) print(service) send mail from email.mime.text import MIMEText from base64 import urlsafe_b64encode from httplib2 import Http from googleapiclient.discovery import build import pickle SENDER = \"sender@email\" RECIPIENT = \"recipient@gm.nfu.edu.tw\" SUBJECT = \"gmail api 寄信測試\" CONTENT = ''' 這是文章內容, http://the.web.site''' creds = None with open('./../client_gmail.pickle', 'rb') as token: creds = pickle.load(token) service = build('gmail', 'v1', credentials=creds) # https://developers.google.com/gmail/api/guides/sending def create_message(sender, to, subject, message_text): \"\"\"Create a message for an email. Args: sender: Email address of the sender. to: Email address of the receiver. subject: The subject of the email message. message_text: The text of the email message. Returns: An object containing a base64url encoded email object. \"\"\" message = MIMEText(message_text) message['to'] = to message['from'] = sender message['subject'] = subject encoded_message = urlsafe_b64encode(message.as_bytes()) return {'raw': encoded_message.decode()} # https://developers.google.com/gmail/api/guides/sending def send_message(service, user_id, message): \"\"\"Send an email message. Args: service: Authorized Gmail API service instance. user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. message: Message to be sent. Returns: Sent Message. \"\"\" try: message = (service.users().messages().send(userId=user_id, body=message) .execute()) print('Message Id: %s' % message['id']) return message #except errors.HttpError, error: except: print('An error occurred: %s' % error) raw_msg = create_message(SENDER, RECIPIENT, SUBJECT, CONTENT) send_message(service, \"me\", raw_msg) Google Drive API translate json to pickle：轉換憑證格式 import pickle from google_auth_oauthlib.flow import InstalledAppFlow from httplib2 import Http from googleapiclient.discovery import build creds = None SCOPES = 'https://www.googleapis.com/auth/drive' # Allows sending only, not reading flow = InstalledAppFlow.from_client_secrets_file( './../client_id.json', SCOPES) creds = flow.run_local_server(port=0) # Save the credentials for the naext run with open('./../client_id_drive.pickle', 'wb') as token: pickle.dump(creds, token) service = build('drive', 'v3', credentials=creds) print(service) quickstart：測試憑證的檔案是否正常 #web url : https://developers.google.com/drive/api/v3/quickstart/python from __future__ import print_function import pickle import os.path from googleapiclient.discovery import build from google_auth_oauthlib.flow import InstalledAppFlow from google.auth.transport.requests import Request # If modifying these scopes, delete the file token.pickle. SCOPES = ['https://www.googleapis.com/auth/drive.metadata.readonly'] def main(): \"\"\"Shows basic usage of the Drive v3 API. Prints the names and ids of the first 10 files the user has access to. \"\"\" creds = None # The file token.pickle stores the user's access and refresh tokens, and is # created automatically when the authorization flow completes for the first # time. if os.path.exists('token.pickle'): with open('token.pickle', 'rb') as token: creds = pickle.load(token) # If there are no (valid) credentials available, let the user log in. if not creds or not creds.valid: if creds and creds.expired and creds.refresh_token: creds.refresh(Request()) else: flow = InstalledAppFlow.from_client_secrets_file( 'credentials.json', SCOPES) creds = flow.run_local_server(port=0) # Save the credentials for the next run with open('token.pickle', 'wb') as token: pickle.dump(creds, token) service = build('drive', 'v3', credentials=creds) # Call the Drive v3 API results = service.files().list( pageSize=10, fields=\"nextPageToken, files(id, name)\").execute() items = results.get('files', []) if not items: print('No files found.') else: print('Files:') for item in items: print(u'{0} ({1})'.format(item['name'], item['id'])) if __name__ == '__main__': main() upload fileg：上傳檔案 from pydrive.auth import GoogleAuth from pydrive.drive import GoogleDrive gauth = GoogleAuth() gauth.LoadClientConfigFile(\"client_secret.json\") #gauth.LocalWebserverAuth() # client_secrets.json need to be in the same directory as the script drive = GoogleDrive(gauth) ''' # View all folders and file in your Google Drive fileList = drive.ListFile({'q': \"'root' in parents and trashed=false\"}).GetList() for file in fileList: print('Title: %s, ID: %s' % (file['title'], file['id'])) # Get the folder ID that you want # 檔案會上傳到根目錄下的 uploaded 目錄中 if(file['title'] == \"uploaded\"): fileID = file['id'] ''' # GDrive 上 uploaded 目錄的 fileID with open(\"./../uploaded_id.txt\", 'r') as content_file: fileID = content_file.read() #uploaded_id.txt content is your target folder ID #fileID = \"your_folder_file_ID\" fileName = \"cat.jpg\" filePath = \"./\" file1 = drive.CreateFile({\"mimeType\": \"image/jpeg\", \"parents\": [{\"kind\": \"drive#fileLink\", \"id\": fileID}], \"title\": fileName}) file1.SetContentFile(filePath + fileName) file1.Upload() # Upload the file. #print('Created file %s with mimeType %s' % (file1['title'], file1['mimeType'])) print(\"upload fileID:\" + str(file1['id'])) file2 = drive.CreateFile({'id': file1['id']}) file2.GetContentFile('./test/downloaded_cat.jpg') # Download file as 'downloaded_cat.jpg under directory test'.","tags":"日誌","url":"./Sep_16_2020.html"},{"title":"Aug 13, 2020 日誌","text":"let's encrypt 數位認證簽章 更新並安裝 pre-requisite software sudo apt-get update sudo apt-get install software-properties-common sudo add-apt-repository universe sudo apt-get update 安裝 certbot sudo apt-get install certbot python3-certbot-nginx 手動編輯 nginx sudo certbot certonly --nginx #ssl_certificate /home/kmol2020/localhost.crt; #ssl_certificate_key /home/kmol2020/localhost.key; ssl_certificate /etc/letsencrypt/live/cad4.kmol.info/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/cad4.kmol.info/privkey.pem; sudo /etc/init.d/nginx restart 測試是否可以成功開啟 https://cad4.kmol.info:9443 http://cad4.kmol.info:88","tags":"日誌","url":"./Aug_13_ 2020.html"},{"title":"Aug 05, 2020 日誌","text":"初步認識及安裝 PyTorch 和 CUDA。 CUDA：利用 GPU 來提升運算效能 PyTorch：開源的 Python 機器學習庫，有類似 Numpy 的張量計算，可用 GPU 加速；自動微分系統的神經網絡 安裝 CUDA 10.2 下載 PyTorch 到 PyTorch 網站選擇符合的系統配置，網頁會顯示安裝指令，再到電腦上執行安裝指令、安裝。 預計 Aug,06 要先去了解一下如何用 let's encrypt 取得認證數位簽章","tags":"日誌","url":"./Aug_05_ 2020.html"},{"title":"Aug 04, 2020 日誌","text":"設定 cad4 server。修復啟動 uWSGI問題，並設定 cmsimde 隨開機啟動。 修復啟動 uWSGI問題 由於在啟動時出現以下問題： probably another instance of uWSGI is running on the same address (:8080). 背景有正在執行的 uWSGI 正在使用相同的 port 8080，所以需要先停止執行背景執行的 uWSGI ，再重啟。 先檢查正在執行的 uWSGI 的 pid 代碼，再用 kill 去停止執行 列出所有正在執行的程式，查看 uWSGI 的 pid 代碼： ps -A 找到相對應的 pid ，用 kill 停止執行 sudo kill pid的號碼 重啟 uWSGI /usr/bin/uwsgi --emperor /home/s40723150/uwsgi_ini 之後再測試是否可以連上 https://[2001:288:6004:17:2020:cad:0:4]:9443 設定 uwsgi service 以管理者身分在 /etc/systemd/system 目錄中建立 cmsimde.service 檔案, 內容如下： [Unit] Description=uWSGI to serve CMSiMDE After=network.target [Service] User=kmol2020 Group=kmol2020 WorkingDirectory=/home/kmol2020/uwsgi_ini ExecStart=/usr/bin/uwsgi --emperor /home/kmol2020/uwsgi_ini [Install] WantedBy=multi-user.target 接著將 cmsimde 服務設為隨系統開機啟動 sudo systemctl enable cmsimde 由於是用 putty 遠端控制，所以就先不重新啟動主機。","tags":"日誌","url":"./Aug_04_ 2020.html"},{"title":"Aug 03, 2020 日誌","text":"設定 cad4 server。設定 nginx uWSGI cmsimde ufw。 導入所需模組 由於pip、uwsgi 和 python plugin 已經安裝了，所以就不裝了。 安裝 cmsimde 所需要的模組(flask、flask_cors、bs4、lxml) sudo pip3 install flask flask_cors bs4 lxml 建立 key and crt 練習時建立自己認證的 key 和 crt 。如果實際要架設 server 就需要第三方任成的 key。 key 和 crt 放在 /home/s40723150 目錄下 sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt 設定 nginx 導入 CMSIMDE 模組 設定 proxy git config --global http.proxy http://[2001:288:6004:17::69]:3128 新建 cad4_site 目錄存放 cmsimde 的檔案 mkdir cad4_site cd cad4_site git clone https://github.com/mdecourse/cmsimde.git 將 up_dir 目錄下的資料複製一份到 cad4_site目錄，為了讓之後啟動網站時讀取資料的配置。 cp -r /home/s40723150/cad4_site/cmsimde/up_dir/* /home/s40723150/cad4_site 設定 nginx 將 /etc/nginx/nginx.conf 裡面的讀取目錄 sites-enabled 替換成 sites-available (第62行)。* 則是讀取到 default ，因為 sites-available 目錄下只有 default 這個檔案。 cd /etc/nginx sudo vi nginx.conf nginx.conf (line: 62) 內容： include /etc/nginx/sites-available/* 修改 sites-available 裡的設定，將 root 的讀取目錄換到 /home/s40723150/cad4_site 。 cd /etc/nginx/sites-available sudo vi default sites-available/default 內容： #root /var/www/html root /home/s40723150/cad4_site; 重啟 nginx sudo /etc/init.d/nginx restart 導入動態網站 sudo vi /etc/nginx/sites-available/default 加入 port 9443 的設定，設定內如下： server { listen 9443 ssl; listen [::]:9443 ssl; # 指定 static 所在位置 location /static { alias /home/s40723150/cad4_site/cmsimde/static/; } location / { # 導入 uwsgi_params 設定參數 include uwsgi_params; # 根目錄設為近端的 8080 port uwsgi_pass 127.0.0.1:8080; } ssl_certificate /home/s40723150/localhost.crt; ssl_certificate_key /home/s40723150/localhost.key; #ssl_certificate /etc/letsencrypt/live/test.kmol.info/fullchain.pem; #ssl_certificate_key /etc/letsencrypt/live/test.kmol.info/privkey.pem; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \"HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES\"; ssl_prefer_server_ciphers on; try_files $uri $uri/ =404; } 在 port 80 後面插入一段 port 88 的設定。 加設 port 88 (sites-available/default)： server { listen 80 default server; listen [::]:80 default_server; listen 88 default_server; listen [::]:88 Idefault_server; 在 nginx (9443) 設定中， 導入 uwsgi_params，其網頁根目錄的資料可以由 uwsgi 網站程式提供。 因為 uwsgi 無 SSL 設置， 因此當內部動態網站以 localhost:8080 將資料送交 Nginx (9443) 之後，可以由 Nginx 提供聯外的 SSL 服務。 開啟 uwsgi 功能 cd /home/s40723150/cad4_site sudo vi init.py 確認 CMSiMDE 中 init.py 設定 uwsgi = True, 表示動態網站系統要以 uwsgi 模式啟動 uwsgi = True 設定 uwsgi.ini 在 /home/s40723150 新建 uwsgi_ini 目錄，專門存放 uwsgi 的設定。 mkdir uwsgi_ini sudo vi uwsgi.ini uwsgi.ini 的設定內容如下： [uwsgi] socket = :8080 uid = s40723150 gid = s40723150 plugins-dir = /usr/lib/uwsgi/plugins/ plugin = python3 master = true process = 4 threads = 2 chdir = /home/s40723150/cad4_site/cmsimde wsgi-file = /home/s40723150/cad4_site/cmsimde/wsgi.py 重啟 nginx sudo /etc/init.d/nginx restart 重新啟動 Nginx 並利用 uwsgi 指令測試 手動啟動 uwsgi 主機的指令︰ /usr/bin/uwsgi --emperor /home/s40723150/uwsgi_ini 此時可以測試是否順利連上 http://[2001:288:6004:17:2020:cad:0:4]:80 、 http://[2001:288:6004:17:2020:cad:0:4]:88 和 https://[2001:288:6004:17:2020:cad:0:4]:9443 。 port 80 和 88 可以連上，port 9443 在啟動後有些問題就先跳過，先設定防火牆。 防火牆設定 (ufw) 以 root 身分進行 ufw 設定，將22 80 9443 一起設定。設定完後可以使用 ufw status 查看防火牆設定。 sudo -s ufw status ufw allow from 2001:288:6004:17::/32 to any port 22 ufw deny 22 ufw allow from 2001:288:6004:17::/32 to any port 80 ufw deny 80 ufw allow from 2001:288:6004:17::/32 to any port 9443 ufw deny 9443 ufw enable exit 退出 root 模式：","tags":"日誌","url":"./Aug_03_ 2020.html"},{"title":"Aug 02, 2020 日誌","text":"學習如何使用opencv。Chapter 8 線條及圖案偵測 Chapter 8 Contour/Shape Detection drawContours Draws contours outlines or filled contours. arcLength Calculates a contour perimeter or a curve length.The function computes a curve length or a closed contour perimeter. approxPolyDP Approximates a polygonal curve(s) with the specified precision. findcontours RETR_EXTERNAL python import cv2 import numpy as np def stackImages(scale, imgArray): rows = len(imgArray) cols = len(imgArray[0]) rowsAvailable = isinstance(imgArray[0], list) width = imgArray[0][0].shape[1] height = imgArray[0][0].shape[0] if rowsAvailable: for x in range(0, rows): for y in range(0, cols): if imgArray[x][y].shape[:2] == imgArray[0][0].shape[:2]: imgArray[x][y] = cv2.resize(imgArray[x][y], (0, 0), None, scale, scale) else: imgArray[x][y] = cv2.resize(imgArray[x][y], (imgArray[0][0].shape[1], imgArray[0][0].shape[0]), None, scale, scale) if len(imgArray[x][y].shape) == 2: imgArray[x][y] = cv2.cvtColor(imgArray[x][y], cv2.COLOR_GRAY2BGR) imageBlank = np.zeros((height, width, 3), np.uint8) hor = [imageBlank] * rows hor_con = [imageBlank] * rows for x in range(0, rows): hor[x] = np.hstack(imgArray[x]) ver = np.vstack(hor) else: for x in range(0, rows): if imgArray[x].shape[:2] == imgArray[0].shape[:2]: imgArray[x] = cv2.resize(imgArray[x], (0, 0), None, scale, scale) else: imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1], imgArray[0].shape[0]), None, scale, scale) if len(imgArray[x].shape) == 2: imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR) hor = np.hstack(imgArray) ver = hor return ver def getContours(img): contours, hierarchy = cv2.find(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) for cnt in contours: area = cv2.contourArea(cnt) print(area) if area > 500: cv2.drawContours(imgContour, cnt, -1, (255, 0, 0), 3) peri = cv2.arcLength(cnt, True) # print(peri) approx = cv2.approxPolyDP(cnt, 0.02 * peri, True) print(len(approx)) objCor = len(approx) x, y, w, h = cv2.boundingRect(approx) if objCor == 3: objectType = \"Tri\" elif objCor == 4: aspRatio = w / float(h) if aspRatio > 0.98 and aspRatio < 1.03: objectType = \"Square\" else: objectType = \"Rectangle\" elif objCor > 4: objectType = \"Circles\" else: objectType = \"None\" cv2.rectangle(imgContour, (x, y), (x + w, y + h), (0, 255, 0), 2) cv2.putText(imgContour, objectType, (x + (w // 2) - 10, y + (h // 2) - 10), cv2.FONT_HERSHEY_COMPLEX, 0.7, (0, 0, 0), 2) path = 'shapes.png' img = cv2.imread(path) imgContour = img.copy() imgGray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) imgBlur = cv2.GaussianBlur(imgGray,(7,7),1) imgCanny = cv2.Canny(imgBlur,50,50) getContours(imgCanny) imgBlank = np.zeros_like(img) imgStack = stackImages(0.6,([img,imgGray,imgBlur], [imgCanny,imgContour,imgBlank])) # cv2.imshow(\"Original\", img) # cv2.imshow(\"Gray\", imgGray) # cv2.imshow(\"Blur\", imgBlur) cv2.imshow(\"Stack\", imgStack) cv2.waitKey(0)","tags":"日誌","url":"./Aug_02_ 2020.html"},{"title":"Jul 30, 2020 日誌","text":"搭車回家，休息一天。","tags":"日誌","url":"./Jul_30_ 2020.html"},{"title":"Jul 29, 2020 日誌","text":"整理 Jul,23~25 的 blog.","tags":"日誌","url":"./Jul_29_ 2020.html"},{"title":"Jul 28, 2020 日誌","text":"學習如何使用opencv。Chapter 7 影像遮罩。 Chapter 7 影像遮罩 while : 迴圈 createTrackbar : 新建軌跡欄 getTrackbarPos : 回傳軌跡欄數值 inRange : 選取範圍(檢查數值在範圍值內留下) bitwise_and ; 遮罩 import cv2 import numpy as np path = 'lambo.png' def empty(a): pass # stackImage def stackImages(scale,imgArray): rows = len(imgArray) cols = len(imgArray[0]) rowsAvailable = isinstance(imgArray[0], list) width = imgArray[0][0].shape[1] height = imgArray[0][0].shape[0] if rowsAvailable: for x in range ( 0, rows): for y in range(0, cols): if imgArray[x][y].shape[:2] == imgArray[0][0].shape [:2]: imgArray[x][y] = cv2.resize(imgArray[x][y], (0, 0), None, scale, scale) else: imgArray[x][y] = cv2.resize(imgArray[x][y], (imgArray[0][0].shape[1], imgArray[0][0].shape[0]), None, scale, scale) if len(imgArray[x][y].shape) == 2: imgArray[x][y]= cv2.cvtColor( imgArray[x][y], cv2.COLOR_GRAY2BGR) imageBlank = np.zeros((height, width, 3), np.uint8) hor = [imageBlank]*rows hor_con = [imageBlank]*rows for x in range(0, rows): hor[x] = np.hstack(imgArray[x]) ver = np.vstack(hor) else: for x in range(0, rows): if imgArray[x].shape[:2] == imgArray[0].shape[:2]: imgArray[x] = cv2.resize(imgArray[x], (0, 0), None, scale, scale) else: imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1], imgArray[0].shape[0]), None,scale, scale) if len(imgArray[x].shape) == 2: imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR) hor= np.hstack(imgArray) ver = hor return ver # ------CreateTrackbar cv2.namedWindow(\"TrackBars\") cv2.resizeWindow(\"TrackBars\",640,240) cv2.createTrackbar(\"Hue Min\",\"TrackBars\",0,179,empty) cv2.createTrackbar(\"Hue Max\",\"TrackBars\",179,179,empty) cv2.createTrackbar(\"Sat Min\",\"TrackBars\",0,255,empty) cv2.createTrackbar(\"Sat Max\",\"TrackBars\",255,255,empty) cv2.createTrackbar(\"Val Min\",\"TrackBars\",0,255,empty) cv2.createTrackbar(\"Val Max\",\"TrackBars\",255,255,empty) while True: img = cv2.imread(path) imgHSV = cv2.cvtColor(img,cv2.COLOR_BGR2HSV) h_min = cv2.getTrackbarPos(\"Hue Min\",\"TrackBars\") h_max = cv2.getTrackbarPos(\"Hue Max\", \"TrackBars\") s_min = cv2.getTrackbarPos(\"Sat Min\",\"TrackBars\") s_max = cv2.getTrackbarPos(\"Sat Max\", \"TrackBars\") v_min = cv2.getTrackbarPos(\"Val Min\",\"TrackBars\") v_max = cv2.getTrackbarPos(\"Val Max\", \"TrackBars\") print(h_min,h_max,s_min,s_max,v_min,v_max) lower = np.array([h_min,s_min,v_min]) upper = np.array([h_max,s_max,v_max]) mask = cv2.inRange(imgHSV,lower,upper) imgResult = cv2.bitwise_and(img,img,mask=mask) # cv2.imshow(\"Original\",img) # cv2.imshow(\"HSV\",imgHSV) # cv2.imshow(\"Mask\",mask) imgStack = stackImages(0.6, ([img, imgHSV], [mask, imgResult])) cv2.imshow(\"Stacked Images\", imgStack) cv2.imshow(\"Result\", imgResult) cv2.waitKey(1)","tags":"日誌","url":"./Jul_28_ 2020.html"},{"title":"Jul 27, 2020 日誌","text":"學習如何使用opencv。Chapter 6 影像排列。 Chapter 6 影像排列 def : 新建一個函數 isinstance : 比對資料格式 hstack : 水平排列 vstack : 垂直排列 import cv2 import numpy as np #------Part1 ''' img = cv2.imread(\"lena.png\") imgHor = np.hstack((img,img)) # 2 range horizontal in a window imgVer = np.vstack((img,img)) # 2 range vertical in a window img4 = np.vstack((imgHor,imgHor)) # 4 images in a window cv2.imshow(\"Horizontal Images\",imgHor) cv2.imshow(\"Vertical Images\",imgVer) cv2.imshow(\"4 Images\",img4) ''' #------Part2 def stackImages(scale,imgArray): rows = len(imgArray) # how many rows(有幾行) cols = len(imgArray[0]) # how many columns(有幾列) rowsAvailable = isinstance(imgArray[0], list) # check if \"imgArray\" is list width = imgArray[0][0].shape[1] # get the first image width size height = imgArray[0][0].shape[0] #get the first image height size if rowsAvailable: for x in range ( 0, rows): for y in range(0, cols): if imgArray[x][y].shape[:2] == imgArray[0][0].shape [:2]: # if the first image size equal to another one imgArray[x][y] = cv2.resize(imgArray[x][y], (0, 0), None, scale, scale) # resize the images else: imgArray[x][y] = cv2.resize(imgArray[x][y], (imgArray[0][0].shape[1], imgArray[0][0].shape[0]), None, scale, scale) # resize the different size image to first image size. if len(imgArray[x][y].shape) == 2: imgArray[x][y]= cv2.cvtColor( imgArray[x][y], cv2.COLOR_GRAY2BGR) # if the image is gray will change to BGR imageBlank = np.zeros((height, width, 3), np.uint8) hor = [imageBlank]*rows hor_con = [imageBlank]*rows for x in range(0, rows): hor[x] = np.hstack(imgArray[x]) ver = np.vstack(hor) else: for x in range(0, rows): if imgArray[x].shape[:2] == imgArray[0].shape[:2]: imgArray[x] = cv2.resize(imgArray[x], (0, 0), None, scale, scale) else: imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1], imgArray[0].shape[0]), None,scale, scale) if len(imgArray[x].shape) == 2: imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR) hor= np.hstack(imgArray) ver = hor return ver img = cv2.imread(\"lena.png\") imgStack = stackImages(0.5,([img,img],[img,img])) cv2.imshow(\"ImagesStack\",imgStack) cv2.waitKey(0)","tags":"日誌","url":"./Jul_27_ 2020.html"},{"title":"Jul 26, 2020 日誌","text":"學習如何使用opencv。Chapter 5 透視轉換。摸索 VScode 設定。 Chapter 5 透視轉換 getPerspectiveTransform : 四點透視轉換 warpPerspective : 矩陣轉圖像 import cv2 import numpy as np img = cv2.imread(\"license_plate_number.jpg\") width,height = 76,31 lpn1_o = np.float32([[188,397],[256,399],[189,432],[265,430]]) lpn1_m = np.float32([[0,0],[width,0],[0,height],[width,height]]) matrix = cv2.getPerspectiveTransform(lpn1_o,lpn1_m) imgOutput = cv2.warpPerspective(img,matrix,(width,height)) imgResize = cv2.resize(imgOutput,(width*3,height*3)) cv2.imshow(\"Image\",img) cv2.imshow(\"Image Output\",imgOutput) cv2.imshow(\"Resize Image\",imgResize) cv2.waitKey(0)","tags":"日誌","url":"./Jul_26_ 2020.html"},{"title":"Jul 25, 2020 日誌","text":"學習如何使用opencv。Chapter 4 插入圖型及文字。 Chapter 4 插入圖型及文字 np.zeros : 產生一個用零填滿的矩陣。我們用來產生一個黑色的畫布(圖片)，之後會在上面插入圖型及文字。 line : 指定兩點畫一直線。 rectangle : 指定兩點畫出一矩形框。 circle : 指定圓心位置，再給定半徑大小。 putText : 輸入要顯示的文字，指定文字的基準位置(左下角)的座標。 import cv2 import numpy as np img = np.zeros((512,512,3),np.uint8) #zero: black . (weith,height,channel) #------Part 1--area print(img) #img[:] = 255,0,0 #a blue square full the black square img[0:100,200:300] = 255,0,0 #blue square[y1:y2,x1:x2] = B,G,R #------Part 2--line #cv2.line(img,(10,10),(300,400),(0,0,255),2) #draw a line : (image,start_point(x0,y0),end_point(x1,y1),color(B,G,R),thickness,line_type) cv2.line(img,(0,0),(img.shape[1],img.shape[0]),(0,255,0),3) #------Part 3--rectangle cv2.rectangle(img,(5,5),(150,240),(180,60,255),2) #a rectangle box:(image,start_point(x0,y0),end_point(x1,y1),color(B,G,R),thickness,line_type) cv2.rectangle(img,(125,125),(250,460),(255,60,180),cv2.FILLED) #a rectangle shape #------Part4--circle cv2.circle(img,(256,256),100,(60,180,255),2) #draw a circle: (image,center_point(x,y),radius,color(B,G,R),thickness,line_type) #------Part5--text cv2.putText(img,\"Opencv\",(200,256),cv2.FONT_ITALIC ,1,(180,180,180),2) #show text: (image,\"text\",org,font_type ,font_scale,color(B,G,R),thickness,line_type) org:Bottom-left corner of the text cv2.imshow(\"Image\",img) cv2.waitKey(0)","tags":"日誌","url":"./Jul_25_ 2020.html"},{"title":"Jul 24, 2020 日誌","text":"學習如何使用opencv。Chapter 3 影像切割及調整尺寸。 Chapter 3 影像切割及調整尺寸 調整影像尺寸( Resize ) Resize Opencv 的 XY 軸座標的原點是在左上角越往右下 X 和 Y 的值越大。 影像切割 import cv2 img = cv2.imread(\"lena.png\") print(img.shape)#show the image size(width,height,channel) imgResize = cv2.resize(img,(1024,1024)) #resize the lean.png:(image,(Y_size,X_size)) print(imgResize.shape) imgCropped = img[200:388,220:355] #cut the image [y1:y2,x1:x2],the origin of image at upper left corner. cv2.imshow(\"Image\",img) cv2.imshow(\"Image Resize\",imgResize) cv2.imshow(\"Cropped Image\",imgCropped) cv2.waitKey(0)","tags":"日誌","url":"./Jul_24_ 2020.html"},{"title":"Jul 23, 2020 日誌","text":"學習如何使用opencv。Chapter 1影像讀取 、Chapter 2 影像轉換。 Opencv 可用於影像處理、電腦視覺、影像辨識等。所以想說先去了解 Opencv 是要如何使用。目前是參考這個影片自己練習。 程式碼網頁 Chapter 1 影像讀取 如何將讀取到的影像、影片或是 Webcam 用 Opencv 呼叫視窗顯示 import cv2 #------part 1 show the lena image ''' img = cv2.imread(\"lena.png\") #read the lena.png cv2.imshow(\"Output\",img) #show lena.png in \"Output\" window cv2.waitKey(0) #\"0\" is mean: hold previous command to user press anykey. ''' #------part 2 show the mp4 video ''' cap= cv2.VideoCapture(\"test_video.mp4\")#read the test_video.mp4 while True: success,img = cap.read() cv2.imshow(\"Video\",img) if cv2.waitKey(3) & 0xFF ==ord('q'): break ''' #------part 3 show the webcam vidoe stream cap = cv2.VideoCapture(0)#Catch camera0 video stream cap.set(3,640) #width of the frames in the video stream cap.set(4,480) #height of the frames in the video stream cap.set(10,128) #brightness of the image (only for cameras) while True: success,img = cap.read() cv2.imshow(\"Capture\",img) if cv2.waitKey(1) & 0xFF ==ord('q'): break Chapter 2 影像轉換 將影像色調轉換 ( 灰階 ) 、高斯模糊、 Canny （邊緣檢測）、 dilate （擴張）、 erode （侵蝕）。 色調轉換 可以將原本的顯示模式 (BGR) 切換成 RGB、HSV、Gray等顯示色調的模式。 Gaussianblur (高斯模糊) Canny dilate erode import cv2 import numpy as np img = cv2.imread(\"lena.png\") kernel = np.ones((5,5),np.uint8) #return a new array of given shape and type, filled with ones. imgGray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) #convert lena.png to gray imgBlur = cv2.GaussianBlur(imgGray,(7,7),0) #blurs an image using a Gaussian filter imgCanny = cv2.Canny(img,195,195) #blurs an image using a Canny filter imgDialation = cv2.dilate(imgCanny,kernel,iterations=1) #dilate Canny filter image imgEroded = cv2.erode(imgDialation,kernel,iterations=1) cv2.imshow(\"Gray Image\",imgGray) cv2.imshow(\"Blur Image\",imgBlur) cv2.imshow(\"Canny Image\",imgCanny) cv2.imshow(\"Dilate Image\",imgDialation) cv2.imshow(\"Eroded Image\",imgEroded) cv2.waitKey(0)","tags":"日誌","url":"./Jul_23_ 2020.html"},{"title":"Jul 22, 2020 日誌","text":"","tags":"日誌","url":"./Jul_22_ 2020.html"},{"title":"Jul 21, 2020 日誌","text":"練習建立 Ubuntu 20.04 server (較完整) 查詢 IP 位址（已安裝 net-tools） ifconfig netplan 設定 （only IPv6） : 重新命名 00-installer-config.yaml 成 net.yaml，為了之後修改網路設定時方便輸入。 cd /etc/netplan sudo mv *.yaml net.yaml 修改網路設定檔 sudo vi net.yaml 將網路設定成純 IPv6 環境，IPv6 網路位址是 16 進制，所以只能使用0~9和 a~f 可以使用，在設定位址時需要注意一下。 設定檔內容（net.yaml）: # This is the network config written by 'subiquity' network: ethernets: enp0s25: addresses: - 2001:288:6004:17:02:cad::3150/64 gateway6: 2001:288:6004:17::254 nameservers: addresses: - 2001:b000:168::1 version: 2 sudo netplan apply proxy 設定（only IPv6） : <---此步驟可以略過 (Aug,06,2020 更) 在純 IPv6 環境下無法 clone github 倉儲，所以需要設定代理主機（porxy）。 到 /etc/apt/apt.conf.d 目錄下修改 proxy 設定。 cd /etc/apt/apt.conf.d sudo vi proxy.conf proxy 設定檔內容（proxy.conf）： Acquire::http::proxy \"http://[2001:288:6004:17::69]:3128\"; 修改後，更新 apt 設定。 sudo apt update 導入所需模組 安裝 python3 的 pip 模組 sudo apt install python3-pip 安裝 cmsimde 所需要的模組（flask、flask_cors、bs4、lxml） sudo pip3 install flask flask_cors bs4 lxml 安裝 uwsgi 和 python plugin sudo apt install uwsgi uwsgi-plugin-python3 安裝 nginx sudo apt install nginx 建立 key and crt 練習時建立自己認證的 key 和 crt 。如果實際要架設 server 就需要第三方任成的 key。 key 和 crt 放在 /home/kmol2020 目錄下 sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt 設定 nginx 導入 CMSIMDE 模組 在 git clone 前先設定 git 會用到的 proxy設定 git config --global http.proxy http://[2001:288:6004:17::69]:3128 為了練習架設網站，所以新建一個 3150_site 目錄在 /home/kmol2020 目錄下，專門來放 cmsimde 的資料。 mkdir 3150_site cd 3150_site git clone https://github.com/mdecourse/cmsimde.git 將 up_dir 目錄下的資料複製一份到 3150_site目錄，為了讓之後啟動網站時讀取資料的配置。 cp -r /home/kmol2020/3150_site/cmsimde/up_dir/* /home/kmol2020/3150_site 設定 nginx 將 /etc/nginx/nginx.conf 裡面的讀取目錄 sites-enabled 替換成 sites-available （第62行）。* 則是讀取到 default ，因為 sites-available 目錄下只有 default 這個檔案。 cd /etc/nginx sudo vi nginx.conf include /etc/nginx/sites-available/* 修改 sites-available 裡的設定，將 root 的讀取目錄換到 /home/kmol2020/3150_site 。 cd /etc/nginx/sites-available sudo vi default #root /var/www/html root /home/kmol2020/3150_site; 重啟 nginx sudo /etc/init.d/nginx restart 導入動態網站 sudo vi /etc/nginx/sites-available/default 加入 port 9443的設定，設定內如下： server { listen 9443 ssl; listen [::]:9443 ssl; # 指定 static 所在位置 location /static { alias /home/kmol2020/3150_site/cmsimde/static/; } location / { # 導入 uwsgi_params 設定參數 include uwsgi_params; # 根目錄設為近端的 8080 port uwsgi_pass 127.0.0.1:8080; } ssl_certificate /home/kmol2020/localhost.crt; ssl_certificate_key /home/kmol2020/localhost.key; #ssl_certificate /etc/letsencrypt/live/test.kmol.info/fullchain.pem; #ssl_certificate_key /etc/letsencrypt/live/test.kmol.info/privkey.pem; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \"HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES\"; ssl_prefer_server_ciphers on; try_files $uri $uri/ =404; } 在 nginx 設定中， 導入 uwsgi_params，其網頁根目錄的資料可以由 uwsgi 網站程式提供。 因為 uwsgi 無 SSL 設置， 因此當內部動態網站以 localhost:8080 將資料送交 Nginx （9443） 之後，可以由 Nginx 提供聯外的 SSL 服務。 開啟 uwsgi 功能 cd /home/kmol2020/3150_site sudo vi init.py 確認 CMSiMDE 中 init.py 設定 uwsgi = True, 表示動態網站系統要以 uwsgi 模式啟動 uwsgi = True 設定 uwsgi.ini 在 /home/kmol2020 新建 uwsgi_ini 目錄，專門存放 uwsgi 的設定。 mkdir uwsgi_ini sudo vi uwsgi.ini uwsgi.ini 的設定內容如下： [uwsgi] socket = :8080 uid = kmol2020 gid = kmol2020 plugins-dir = /usr/lib/uwsgi/plugins/ plugin = python3 master = true process = 4 threads = 2 chdir = /home/kmol2020/3150_site/cmsimde wsgi-file = /home/kmol2020/3150_site/cmsimde/wsgi.py 重啟 nginx sudo /etc/init.d/nginx restart 若出現錯誤，有可能是 /etc/nginx/sites-available/default 內容有誤。訂正完重啟就可以了。 重新啟動 Nginx 並利用 uwsgi 指令測試 手動啟動 uwsgi 主機的指令︰ /usr/bin/uwsgi --emperor /home/kmol2020/uwsgi_ini 此時可以測試是否順利連上 http://[2001:288:6004:17:2:cad:0:3150]:80 和 https://[2001:288:6004:17:2:cad:0:3150]:9443 ，若沒問題再設定防火牆。 防火牆設定 （ufw） 以 root 身分進行 ufw 設定，將22 80 9443 一起設定。設定完後可以使用 ufw status 查看防火牆設定。 sudo -s ufw status ufw allow from 2001:288:6004:17::/32 to any port 22 ufw deny 22 ufw allow from 2001:288:6004:17::/32 to any port 80 ufw deny 80 ufw allow from 2001:288:6004:17::/32 to any port 9443 ufw deny 9443 ufw enable 若要退出 root 模式： exit 假如網路不在系上網段, 則需要設定 140.130.17.4:3128 作為代理主機才能連線. 因為 ufw 設定都必須在 sudo 權限下, 因此使用 sudo -s 直接以 root 身份執行後續的指令. 初學者在練習 ufw 時可以在虛擬主機中設定, 避免在遠端連線時, 因設定錯誤而無法 ssh 至主機. 設定 uwsgi service 以管理者身分在 /etc/systemd/system 目錄中建立 cmsimde.service 檔案, 內容如下: [Unit] Description=uWSGI to serve CMSiMDE After=network.target [Service] User=kmol2020 Group=kmol2020 WorkingDirectory=/home/kmol2020/uwsgi_ini ExecStart=/usr/bin/uwsgi --emperor /home/kmol2020/uwsgi_ini [Install] WantedBy=multi-user.target 接著將 cmsimde 服務設為隨系統開機啟動 sudo systemctl enable cmsimde 若要取消 cmsimde 服務隨系統開機啟動 sudo systemctl disable cmsimde 手動啟動 cmsimde.service 服務 sudo systemctl start cmsimde 手動停止 cmsimde.service 服務 sudo systemctl stop cmsimde","tags":"日誌","url":"./Jul_21_ 2020.html"},{"title":"Jul 20, 2020 日誌","text":"練習建立server。修改網路設定，設定跟隨開機啟動。 將網路設定，設定成純 IPv6 設定。 IPv6 網路位址是 16 進制，所以只能使用0~9和 a~f 可以使用。 可將網路設定檔更名，以便之後設定時修改。 sudo mv *.yaml net.yaml 設定 uwsgi service 以管理者身分在 /etc/systemd/system 目錄中建立 cmsimde.service 檔案, 內容如下: [Unit] Description=uWSGI to serve CMSiMDE After=network.target [Service] User=kmol2020 Group=kmol2020 WorkingDirectory=/home/kmol2020/uwsgi_ini ExecStart=/usr/bin/uwsgi --emperor /home/kmol2020/uwsgi_ini [Install] WantedBy=multi-user.target 接著將 cmsimde 服務設為隨系統開機啟動: sudo systemctl enable cmsimde 若要取消 cmsimde 服務隨系統開機啟動： sudo systemctl disable cmsimde 手動啟動 cmsimde.service 服務 sudo systemctl start cmsimde 手動停止 cmsimde.service 服務 sudo systemctl stop cmsimde","tags":"日誌","url":"./Jul_20_ 2020.html"},{"title":"Jul 19, 2020 日誌","text":"整理Jul,15~18的blog。 今天在整理15~18日誌，還有整理房間。","tags":"日誌","url":"./Jul_19_ 2020.html"},{"title":"Jul 18, 2020 日誌","text":"練習建立server。 設定 ufw sudo -s ufw status ufw allow from 2001:288:6004:17::/32 to any port 22 ufw deny 22 ufw allow from 2001:288:6004:17::/32 to any port 80 ufw deny 80 ufw enable 假如網路不在系上網段, 則需要設定 140.130.17.4:3128 作為代理主機才能連線. 因為 ufw 設定都必須在 sudo 權限下, 因此使用 sudo -s 直接以 root 身份執行後續的指令. 初學者在練習 ufw 時可以在虛擬主機中設定, 避免在遠端連線時, 因設定錯誤而無法 ssh 至主機. 退出root身分：exit 先暫時關閉防火牆 ufw disable 允許設計系 IP v6 網段連線 9443 port ufw allow from 2001:288:6004:17::/32 to any port 9443 其他網段主機一律]不准連線 ufw deny 9443 重新開啟 ufw 防火牆 ufw enable 做到步驟，不確定如何測試是否可以成功連線。","tags":"日誌","url":"./Jul_18_ 2020.html"},{"title":"Jul 17, 2020 日誌","text":"練習建立server。 Ubuntu 20.04 server 安裝會使用到的模組 安裝 pip 模組 sudo apt install python3-pip 安裝 cmsimde 所需的模組 sudo pip3 install flask flask_cors bs4 lxml 安裝 uwsgi 、 python plugin sudo apt install uwsgi uwsgi-plugin-python3 安裝 python 模組 uwsgi、nginx sudo apt install uwsgi sudo apt install nginx 建立 key 和 crt 在 /home/kmol2020 目錄下執行 sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt 設定 nginx cd /etc/nginx sudo vi nginx.conf 將 nginx.conf 第62行︰ sites-enabled/ 換成 sites-available/ sites-available/* 導入 cmsimde 在 /home/kmol2020 目錄下新增一個 test_site 目錄，，將 cmsimde clone 下來。 mkdir test_site cd test_site git clone https://github.com/mdecourse/cmsimde.git 將 up_dir 目錄裡面的資料複製到 test_site 目錄下 cp -r /home/kmol2020/test_site/cmsimde/up_dir/* /home/kmol2020/test_site 更改 root 預設讀取目錄 cd /etc/nginx/sites-available sudo vi default #root /var/www/html root /home/kmol2020/test_site 重啟 nginx sudo /etc/init.d/nginx restart 導入 uwsgi 動態網站 sudo vi /etc/nginx/sites-available/default 將 nginx 設定檔導入 uwsgi_params。其網頁根目錄的資料可以由 uwsgi 網站程式提供 因為 uwsgi 無 SSL 設置, 因此當內部動態網站以 localhost:8080 將資料送交 Nginx 之後, 可以由 Nginx 提供聯外的 SSL 服務. server { listen 9443 ssl; listen [::]:9443 ssl; # 指定 static 所在位置 location /static { alias /home/kmol2020/test_site/cmsimde/static/; } location / { # 導入 uwsgi_params 設定參數 include uwsgi_params; # 根目錄設為近端的 8080 port uwsgi_pass 127.0.0.1:8080; } ssl_certificate /home/kmol2020/localhost.crt; ssl_certificate_key /home/kmol2020/localhost.key; #ssl_certificate /etc/letsencrypt/live/test.kmol.info/fullchain.pem; #ssl_certificate_key /etc/letsencrypt/live/test.kmol.info/privkey.pem; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \"HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES\"; ssl_prefer_server_ciphers on; try_files $uri $uri/ =404; } 開啟 ini.py 的 uwsgi 功能 cd /home/kmol2020/test_site sudo vi init.py uwsgi = True 確認 CMSiMDE 中 init.py 設定 uwsgi = True, 表示動態網站系統要以 uwsgi 模式啟動 設定 uwsgi.ini 在 /home/kmol2020 目錄下新建 uwsgi_ini 的子目錄 mkdir uwsgi_ini sudo vi uwsgi.ini [uwsgi] socket = :8080 uid = kmol2020 gid = kmol2020 plugins-dir = /usr/lib/uwsgi/plugins/ plugin = python3 master = true process = 4 threads = 2 chdir = /home/kmol2020/test_site/cmsimde wsgi-file = /home/kmol2020/test_site/cmsimde/wsgi.py 重啟 nginx sudo /etc/init.d/nginx restart 若出現錯誤，有可能是 /etc/nginx/sites-available/default 內容有打錯。修改完再重啟一次就可以了。 重新啟動 Nginx 並利用 uwsgi 指令測試 手動啟動 uwsgi 主機的指令︰ /usr/bin/uwsgi --emperor /home/kmol2020/uwsgi_ini","tags":"日誌","url":"./Jul_17_ 2020.html"},{"title":"Jul 16, 2020 日誌","text":"","tags":"日誌","url":"./Jul_16_ 2020.html"},{"title":"Jul 15, 2020 日誌","text":"調整背英文單字的模式。","tags":"日誌","url":"./Jul_15_ 2020.html"},{"title":"Jul 14, 2020 日誌","text":"整理Jul,10~12的日誌。 手寫數字影像辨識","tags":"日誌","url":"./Jul_14_ 2020.html"},{"title":"Jul 13, 2020 日誌","text":"整理大間實驗室，整理和更新電腦。 大間實驗室的東西要撤走，之後給五專生的科學會的空間，在整理得時候發現有很多以前留下來的書和設備，有將一些原文書和工具書。 下午將之後練習Keras和Pytouch用的電腦升級 Windows10 的版本。","tags":"日誌","url":"./Jul_13_ 2020.html"},{"title":"Jul 12, 2020 日誌","text":"帶樂高營，第二天。 小隊員與對輔比較熟悉，在互動上就比較有回應。在教程式時他們雖然沒什麼反應，但在測試時他們是了解程式運的步驟。在比賽時看到其他小隊較不適當的方式時，他們還是會堅持自己的原則：不會用投機的方式贏得比賽，比完賽後會參考前幾場的經驗去改進，小隊員之間會相互分享討論經驗。 這兩天下來，發現有小朋友會特別在意某些點，即使本意是好的，但會因為不善於溝通會造成小衝突。溝通是團隊合作不可或缺的關鍵。","tags":"日誌","url":"./Jul_12_ 2020.html"},{"title":"Jul 11, 2020 日誌","text":"帶樂高營，第一天。 剛開始和小隊員互動他們可能因為不熟又比較內向，所以在互動上必較沒有回應，但他們有進入狀況：在教他們小隊呼的時候會跟著做：在合作的方面表現很好，會一起組裝，沒有吵架的情形。在小隊比賽時，即使小隊員失誤而沒贏得比賽也不會一味的指責，反而會互相相交流進步。 一整天下來，整個小隊員的表現都很好。特殊生的部分：其實比較需要去留意他們的情形，像亞斯伯格就講話比較直接，有時候就會因此而造成小隊員之間的衝突，需要協調、安慰小隊員，這時溝通技巧就很重要。照顧故特殊生需要比較多的耐心和技巧。","tags":"日誌","url":"./Jul_11_ 2020.html"},{"title":"Jul 10, 2020 日誌","text":"整理 Jul,7~8 的資料。Ubuntu 20.04、動態網站（nginx、uwsgi）、數位簽章、Ubuntu防火牆（ufw） Ubuntu 20.04 動態網站（nginx、uwsgi） 因為 CMSiMDE 的動態網站需要 flask、flask_cors、bs4 與 lxml 等模組，所以要先確定 Ubuntu 20.04 中的 Python3 已經安裝這些模組： sudo pip3 install flask flask_cors bs4 lxml uwsgi 所需模組： 安裝 uwsgi 套件與 Python3 plugin sudo apt install uwsgi uwsgi-plugin-python3 安裝 Python 模組 uwsgi sudo pip3 install uwsgi 建立 crt 與 key，並修改 Nginx sites-available/default，加入執行 uwsgi 動態網站的設定（/etc/nginx/sites-available/default 附加 server 設定 ）： 建立 localhost.key 與 localhost.crt： sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt server { listen 9443 ssl; listen [::]:9443 ssl; # 指定 static 所在位置 location /static { alias /home/yen/cad1_site/cmsimde/static/; } location / { # 導入 uwsgi_params 設定參數 include uwsgi_params; # 根目錄設為近端的 8080 port uwsgi_pass 127.0.0.1:8080; } ssl_certificate /home/yen/localhost.crt; ssl_certificate_key /home/yen/localhost.key; #ssl_certificate /etc/letsencrypt/live/cad1.kmol.info/fullchain.pem; #ssl_certificate_key /etc/letsencrypt/live/cad1.kmol.info/privkey.pem; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \"HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES\"; ssl_prefer_server_ciphers on; try_files $uri $uri/ =404; } 上述設定的基本概念為：Nginx 設定檔案中, 只要導入 uwsgi_params，其網頁根目錄的資料可以由 uwsgi 網站程式提供。 因為 uwsgi 無 SSL 設置，因此當內部動態網站以 localhost:8080 將資料送交 Nginx 之後, 可以由 Nginx 提供聯外的 SSL 服務。 uwsgi 主機設定 首先確認 CMSiMDE 中 init.py 設定 uwsgi = True，表示動態網站系統要以 uwsgi 模式啟動 接著將利用 uwsgi 啟動模式中的 emperor 選項，每一台主機只要提供一個 .ini 設定檔案，並集中放在某一目錄中，只要在啟動 uwsgi 時，指定該存放 .ini 設定檔案的目錄位置，uwsgi emperor 模式會一一讀取，配合啟動各 uwsgi server。 目前將此一設定目錄放在 /home/yen/enabled, 而設定檔案 uwsgi.ini 則放入 uwsgi_ini 目錄中。 uwsgi.ini 配合設為： [uwsgi] socket = :8080 uid = yen gid = yen plugins-dir = /usr/lib/uwsgi/plugins/ plugin = python3 master = true process = 4 threads = 2 chdir = /home/yen/cad1_site/cmsimde wsgi-file = /home/yen/cad1_site/cmsimde/wsgi.py 表示要使用 8080 傳輸資料 （必須與 Nginx /etc/nginx/sites-available/default 中的設，定對應）並指定 wsgi.py 所在目錄。 重新啟動 Nginx 並利用 uwsgi 指令測試 手動啟動 uwsgi 主機的指令： /usr/bin/uwsgi --emperor /home/yen/uwsgi_ini 額外加入 ufw 9443 的防火牆設定 先暫時關閉 ufw ufw disable 允許設計系 IP v6 網段連線 9443 port ufw allow from 2001:288:6004:17::/32 to any port 9443 其他網段主機一律]不准連線 ufw deny 9443 重新開啟 ufw 防火牆 ufw enable 若 https://cad1.kmol.info:9443 已經可以接受連線, 接下來最後一個步驟必須設定以系統 service 隨機啟動 uwsgi 設定 uwsgi service 以管理者身分在 /etc/systemd/system 目錄中建立 cmsimde.service 檔案, 內容如下: [Unit] Description=uWSGI to serve CMSiMDE After=network.target [Service] User=yen Group=yen WorkingDirectory=/home/yen/uwsgi_ini ExecStart=/usr/bin/uwsgi --emperor /home/yen/uwsgi_ini [Install] WantedBy=multi-user.target 接著將 cmsimde 服務設為隨系統開機啟動: sudo systemctl enable cmsimde 若要取消 cmsimde 服務隨系統開機啟動: sudo systemctl disable cmsimde 手動啟動 cmsimde.service 服務 sudo systemctl start cmsimde 手動停止 cmsimde.service 服務 sudo systemctl stop cmsimde 上面完整的步驟也寫在 mdecourse/project2020-1#4 完成後, 只允許系上 IPv6 網段可以直接連到 https://cad1.kmol.info:9443 以 4072kmol 登入管理後改版, 直接 generate pages 就可以在 http://cad1.kmol.info 看到. 數位簽章 https://letsencrypt.org/ https://certbot.eff.org/lets-encrypt/ubuntufocal-nginx sudo apt-get update sudo apt-get install software-properties-common sudo add-apt-repository universe sudo apt-get update sudo apt-get install certbot python3-certbot-nginx sudo certbot certonly --nginx sudo certbot renew --dry-run Ubuntu防火牆（ufw） ufw 是 Ubuntu 內建的防火牆, 與 KMOLab 有關的設定： sudo -s ufw status ufw allow from 2001:288:6004:17::/32 to any port 22 ufw deny 22 ufw allow from 2001:288:6004:17::/32 to any port 80 ufw deny 80 ufw enable sudo -s 是直接輸入具管理者身份的密碼後，就可以採 root 身份執行後續的指令，退出 root，輸入 exit ufw status 是列出目前防火牆狀態，確認為 inactive 後再進行後續的 rules 設定。 ufw allow from 2001:288:6004:17::/32 to any port 22 表示允許從 2001:288:6004:17::/32 來的連線可以使用 port 22，也就是可以使用 ssh 對主機連線。 2001:288:6004:17::/32 中之 32，表示前面 IPv6 網址，只要前面四個區為 2001:288:6004:17 即符合條件，因為每一區 8 個 bit，因此才以 /32 表示涵蓋的範圍。 先設定允許對 port 22 連線的區段後，隨即以 ufw deny 22 封鎖其他非 allow 的所有網段，目的在於只允許系上 IPv6 網段可以 ssh 到主機。 隨後也是只允許系上網段可以連線到 port 80，也就是 www 內建的 port。","tags":"日誌","url":"./Jul_10_ 2020.html"},{"title":"Jul 9, 2020 日誌","text":"列印風扇支架。嘗試將按add_to_mblogger 之後會新增 blog_id 子節點為post_id。 因為最大台3D印表機的擠料頭的散熱風扇掉落，需要固定，因此利用Onshape 畫風扇支架。 一開始的模型，風扇上面與擠料頭固定的地方寬度太寬基線開關會壓不到，之後寬度改窄。風扇的卡槽寬度需要改大，因為裝上的時候太緊。 第一次改版 改完後發現，會和擠出頭的固定螺絲卡到，因此在那挖個槽，消除干涉。 修改完組裝後","tags":"日誌","url":"./Jul_09_ 2020.html"},{"title":"Jul 8, 2020 日誌","text":"看nginx、uwsgi、ufw設定。 nginx：非同步框架的網頁伺服器。（內建支援uwsgi） uwsgi：讓多個執行序常駐啟動，有任務進來時丟給這些執行序處理，處理完之後回傳 ufw︰Ubuntu 的防火牆。 資料大致上看過，還沒整理，剩 uwsgi 、 ubuntu 20.04 guide 還沒看。 下午樂高營開會。 Jul,1 修的3D印表機搬位置後噴頭移動沒反應。暫時先布維修。 晚上有用最大台的3D印表機印東西，之後因為平面偏移、斷料、風扇掉落停止列印。","tags":"日誌","url":"./Jul_08_ 2020.html"},{"title":"Jul 7, 2020 日誌","text":"今天在做皮件。還有稍微看一下老師傳的資料。 皮件製作流程 打版： 將要做的皮件的展開圖畫好，可以利用較高磅數的紙或是木板來當作裁皮的版型。 裁皮： 將先前製作好的版型放在皮上，用鐕子或筆畫上裁切的記號、邊線。 染色、塗保色劑（可有可無）： 染色的染料有分鹽基和酒精性的染劑。染完色可以塗保色劑來讓染好的皮革較不容易退色。 上床面處理劑： 床面處理劑是塗在毛面（非光滑面，較粗糙那面），讓毛面的纖維比較平整。 推邊： 讓皮革邊緣不會呈現直角，之後磨邊後會比較好摸。 6.磨邊： 將邊緣磨光滑，讓皮的纖維不會跑出來影響觸感。 7. 打孔： 用菱斬打縫孔，由於皮的厚度比較厚也比一般的布強度強，用針不容一刺穿皮革，打過縫孔後，皮片手縫會很輕鬆。 8. 縫合： 用蠟線縫合皮片，組合成皮件（像皮包、皮夾等）。手縫都使用雙針縫。 9. 磨邊、上油： 縫合後將邊緣磨平（接縫處），在將它磨光滑。完成後皮革的表面可以上一層保護油、保養油，讓皮革較為柔軟。 成品 專題資料 了解專題的伺服器如何配置。","tags":"日誌","url":"./Jul_07_ 2020.html"},{"title":"Jul 6, 2020 日誌","text":"利用防寫卡、clonezilla複製磁區，在Ubuntu 20.04新增管理員。 防寫卡複製 step 0 來源端與接收端需要在同一個網路下，中斷與外部連線網路。 step 1 先開機要複製出去（資料來源）那台的電腦，在防寫卡畫面（選擇磁區畫面）按下\"F10\"進入防寫卡設定，輸入密碼，在系統管理畫面，選擇左方的網路拷貝，拷貝環境：32位元；網卡類型：11 : Intel 1G ndis。 step2 設定好按套用設定，再進行網路拷貝（按網路拷貝按鈕）。選擇\"模式1\"為拷貝模式，確認接收端開機自動連線是勾選。按網路拷貝按鈕 step3 網路拷貝：將整個選擇的磁區內容、設定複製過去。覆蓋。 增量拷貝：將選擇的磁區不同的內容、設定複製過去。覆蓋。 選擇要複製的選項（視情況選擇網路拷貝或增量拷貝），確定，等待登錄。 step4 開啟接收端電腦，進入防寫卡畫面（選擇磁區畫面）按下\"F9\"進入防寫連線傳輸，輸入密碼。 傳送端電腦，查看是否與連上接收端電腦連上，連上後清單列表上會顯示，按完成登錄，發送資料。 step5 若是要複製第三磁區，選擇複製單一作業統，選第三磁區，勾選C槽，傳輸完成後需要重新啟動接收端電腦，順一次複製後設定。重啟後可順便檢查接上外部網路後是否可以正常連線。 clonezilla硬碟複製 clonezilla硬碟複製 開機前硬體確認：硬碟與光碟機連接順序。 1.備份硬碟來源 （a硬碟） 2. 光碟機 3. 存放備份的硬碟（b硬碟） P.S. 存放備份的硬碟（b硬碟）需要比 備份硬碟來源 （a硬碟） 的容量大一樣大或更大，比備份來源小會無法複製。 利用clonezilla來進行複製硬碟，事先須準備一片已經入燒入進去clonezilla的光碟（到網路上下載clonezilla的iso檔燒錄到光碟裡），開機時放入clonezilla光碟片，並進入\"開機選單\"（進入開機選單的快捷鍵會因為各廠牌的電腦而有所不同，當時測試為aser電腦，在出現電腦商logo時按\"F12\"就進入開機選單）會些換到用光碟機開機（會去讀取clonezilla光碟的資料）。等待一段時間後會進到clonezilla的畫面，選英文，鍵盤定選預設，接下來選硬碟對硬碟（disk to disk）進行複製，硬碟來源選 a硬碟，接收選 b硬碟，其他設定都是預設選項（包括其他未提到的設定），開始複製硬碟，按Enter，2次y（確認覆蓋開機磁區），複製的時間會因硬碟大小而有所差異（當時複製160GB大約是2分鐘），複製完成後關機。 P.S. clonezilla 硬碟複製是bit by bit，硬碟分割模式為MBR的硬碟在複製的時候開機磁區也會同時複製，不需特別抹除原來的MBR。若硬碟安裝作業系統時無法覆蓋先前的MBR磁區，就必須用clonezilla複製去覆蓋。 硬碟分割分 MBR 和 GPT兩種。 Ubuntu 20.04 建立管理者 sudo adduser 使用者名稱 輸入登入者的密碼, 以便使用 sudo 管理者身分執行 adduser 然後輸入 \"使用者名稱\" 預設密碼與基本資料後, 準備將 \"使用者\" 設為管理者 sudo usermod -aG sudo s40723150 利用 usermod 指令授予 sudo 權限, 有關 usermod 使用說明, 可以利用 man usermod 取得 刪除管理者 可以刪除 \"使用者\" 帳號與其 /home/wcm1 對應用戶目錄。 sudo deluser --remove-home 使用者名稱 修改主機名稱 牽涉兩個檔案 /etc/hosts 與 /etc/hostname, 修改後必須重新開機 sudo vi /etc/hosts 將 wcm1 改為 cad1 或 cad2 或其他主機對應名稱 sudo vi /etc/hostname 也是將 wcm1 改為 主機對應名稱 修改網路設定 到/etc/netplan/net.yaml修改網路設定 （sudo mv *.yaml net.yaml 將網路設定的yaml重新命名成 net.yaml） ssh 使用者@要連上的主機位置","tags":"日誌","url":"./Jul_06_ 2020.html"},{"title":"Jul 5, 2020 日誌","text":"了解 delta printer 的正向與逆向運動方程式 Delta printer是運用 Stewart Platform 機構修改出來的機構，一樣有6個自由度。 Stewart Platform 可伸縮連桿的部分 Delta printer 換成兩個連桿來達到同的功能。 正向（順向）運動學（forward kinematics） 由各關節變數求效應器（機構末端）的位置與方向角 反向運動學（invers kinematics） 由末端效應器（機構）的位置與方向求各關節變數","tags":"日誌","url":"./Jul_05_ 2020.html"},{"title":"Jul 4, 2020 日誌","text":"嘗試利用 Python程式將 Plican 網誌傳送到 Blogger，成功傳送到 Blogger。 新增/編輯文章到blogger 到想新增/修改的文章對應到的markdown節點，按 add_to_mblogger 按鈕。想修改按 edit_to_mblogger按鈕。 修改成功的話會顯示： post_id 為 一串文章的ID 已經將更新資料送往 M Blogger! 文章內的圖片要放絕對位置（網址） 若出現 google.auth.exceptions.RefreshError: ('invalid_scope: Some requested scopes were invalid. {invalid=[a, b, c, e, g, h, i, l, m, ., /, o, p, r, s, t, u, w, :]}', '{\\n \"error\": \"invalid_scope\",\\n \"error_description\": \"Some requested scopes were invalid. {invalid\\u003d[a, b, c, e, g, h, i, l, m, ., /, o, p, r, s, t, u, w, :]}\",\\n \"error_uri\": \"http://code.google.com/apis/accounts/docs/OAuth2.html\"\\n}') 重新轉一次.dat應該可以解決新增/編輯文章到blogger","tags":"日誌","url":"./Jul_04_ 2020.html"},{"title":"Jul 3, 2020 日誌","text":"嘗試利用 Python程式將 Plican 網誌傳送到 Blogger，但還沒成功。 將json轉檔成 .pickle 和 .dat 想將Pelican網誌利用Pyrhon程式把文章傳到Blogger，我有參考 新增 按鈕執行程式 裡面的程式碼， Google API 新增Blogger API，去取得json的檔案。 獲取client_secrets.json： 登錄到您的@gm帳戶 到 Google API 接受許可並創建Google API項目 啟用Google Blogger API v3 選擇內部用戶類型並添加新的應用程序名稱 在\" API和服務\"下，進入\"憑證\"頁面 為電腦版應用程式創建\" OAuth 2.0客戶端ID\"類型的憑據 下載json檔 接下來 測試json ，裡面的程式碼是用來測試.json是否正常，正常的話再將.json轉檔成 .pickle 和 .dat。 到 project2020-1倉儲的tools gmail_json_to_pickle.py是將json轉成pickle，blogger_json_to_pickle.py也是轉成pickle，但存成dat。由於Blogger 憑證與 Gmail 憑證的差異在於 SCOPES 與 build 時 LIbrary 名稱與版本的差異，所以需要分別轉出來。 轉出來的 .pickle 和 .dat 以及一開始下載的 .json 都需要放在倉儲目錄外部 @button 裡面的程式，.dat要指到對應的檔案（剛剛轉出來的），blog_id是對應到該網誌ID，post_id則是代 表文章的ID","tags":"日誌","url":"./Jul_03_ 2020.html"},{"title":"Jul 2, 2020 日誌","text":"暑假三大重點 複製0810教室的磁碟，學會防寫卡硬碟複製 clonezilla硬碟複製 單機 網路 架設深度學習的主機 學會Keras（Python編寫的開源神經網路庫）和Pytorch（開源的Python機器學習庫），看會Keras的電子書學會影像辨識手寫數字","tags":"Misc","url":"./Jul_02_ 2020.html"},{"title":"Jul 1, 2020 日誌","text":"日誌 維修3D列印：噴嘴加熱和原點Z軸校正 維修張元學長那屆當時組的3D印表機，目前發現兩個問題 噴嘴加熱（無法加熱） 已解決 線路當時情況 原始接線 各插槽功能 修正後(噴頭接A13，底板加熱A14) 2. Z軸歸零後與底板還有一段距離 我們一開始先讓機器回歸原點，發現離下面的平台至少有14mm左右，然後稍微嘗試一下，發現印表機的介面沒有可以單獨控制Z軸的選項，只有L R B三個回歸原點和Home All（同Auto home的功能），所以初步推測要校正Z軸原點的位置可能需要去修改firmware（韌體），在網路上一番搜尋後，找到Marlin和Repetier都是可以裝在控制3D印表機的韌體。後來大三學長拿了之前學長的書面資料給我們看，發現當時是使用Repetier的firmware，其中\"Configuration.h\"是機台主要參數設定的檔， repetier firmware 可以上傳舊的Configuration.h 或 config.json進行參數設定的更新。 連接3D印表機控制板的USB線到電腦後就出現COM3 將操控板連到電腦當時讀到的位置是COM3 Pronterface 介面 Pronterface 可以透過介面上按鈕或是G-cord控制3D印表機噴頭位置，選到正確的Port按connect就可以連上。 File link 當時下載的檔案 https://www.repetier.com/firmware/v100/config.php?a=downloadAll http://download.repetier.com/files/host/win/setupRepetierHost_2_1_6.exe http://kliment.kapsi.fi/printrun/Printrun-win-18Nov2017.zip Website URL https://forum.duet3d.com/topic/3800/resetting-the-origin-of-a-delta https://www.pronterface.com/","tags":"日誌","url":"./Jul_01_2020.html"}]};